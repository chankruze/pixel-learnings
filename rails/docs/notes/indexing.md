An index is a database structure which stores the values of a column in a specific order. It contains keys or records built from a column of the corresponding table.

When you query a record, the database goes to that index first and finds a reference of the record and then retrieves the corresponding table records.

It is relatively quicker to retrieve an index from the database than to retrieve a record since indexes are ordered. This can speed up the query process.

While it stands to reason to use an index for speeding up read operations, it has its downside as well. Unnecessary usage of the index can slow down write operations like insert and update. Additionally, if a column, whose values change frequently, is used for forming a clustered index, then it can further slow down operations. This is because the records would have to be reordered after each update of the column value. Columns that store large data are also not ideal for adding index since they can be highly inefficient.

A unique index is a type of index that ensures that the indexed column contains only distinct values.

One key difference between an index and a unique index is that a unique index prevents duplicate values from being entered into the indexed column, whereas a regular index does not. This means that a unique index can be thought of as a type of constraint that helps to maintain the integrity of the data in a table.

A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, causing negative outcomes as opposed to the case when these processes are executed synchronously.

Our API is still prone to race condition even after we have added `validates :key, uniqueness: true` in the model.

To prevent this, we need to add a `unique` constraint at the database level. Once a unique constraint is added, database automatically creates a unique index to enforce the uniqueness requirement.

When a database transaction is initiated, database examines the existing data for columns with a unique constraint in their respective indices to make sure all values are unique. If the values are not unique then database will return an error message.

Therefore, after adding a unique constraint, we could monitor for failure scenarios by catching the `ActiveRecord::RecordNotUnique` exception and send back our custom error message.

```shell
bundle exec rails generate migration AddUniqueIndexForSlug
```

Add the following lines of code in the migration file:

```ruby
class AddUniqueIndexForSlug < ActiveRecord::Migration[7.1]
  def change
    add_index :tasks, :slug, unique: true
  end
end
```

> Note:
>
> It is important to note that, handling ActiveRecord::RecordNotUnique exception will be different for emails and slugs.
>
> For attributes whose value is provided by the user, like an email field, we should notify the user that the value entered is not unique and prompt them to enter a new unique value.
>
> Whereas for an attribute like slug, where the value is generated by application, we need to handle the exception and generate a unique value.

We also need to change routes to make use of slug instead of id on task resource route. By default, Rails uses the :id identifier to denote the dynamic routes for a resource. For example, by default for a route with the pattern `/tasks/:slug`, the value of slug will be available to the controller using `params[:id]`, which can cause confusion as we already have an id field in the Task model and since slug is actually not the id of a table.

To avoid this confusion, Rails lets us override the default name by using param like this:

```ruby
resources: tasks, param: :identifier_name
```
